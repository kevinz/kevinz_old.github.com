<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C | Code Mind]]></title>
  <link href="http://gekben.gitcd.com/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://gekben.gitcd.com/"/>
  <updated>2013-03-19T08:31:40+08:00</updated>
  <id>http://gekben.gitcd.com/</id>
  <author>
    <name><![CDATA[Kevin Zeng]]></name>
    <email><![CDATA[kevintech08@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TCP状态迁移及状态码]]></title>
    <link href="http://gekben.gitcd.com/blog/2012/08/09/check-tcp-connections/"/>
    <updated>2012-08-09T11:39:00+08:00</updated>
    <id>http://gekben.gitcd.com/blog/2012/08/09/check-tcp-connections</id>
    <content type="html"><![CDATA[<p>{% imgpopup /images/post_img/Tcp_state_diagram.svg  50%  %}</p>

<p>想必大家对上图都比较熟悉了，补充下内核里对以上状态码的表示，顺便对源代码做了下改动，每个
状态的代码都补出来了。</p>

<p>{% codeblock tcp_state.h lang:c %}</p>

<p>enum {</p>

<pre><code>TCP_ESTABLISHED = 1,
TCP_SYN_SENT    = 2,
TCP_SYN_RECV    = 3,
TCP_FIN_WAIT1   = 4,
TCP_FIN_WAIT2   = 5,
TCP_TIME_WAIT   = 6
TCP_CLOSE       = 7, 
TCP_CLOSE_WAIT  = 8,
TCP_LAST_ACK    = 9,
TCP_LISTEN      = 10,
TCP_CLOSING     = 11,   /* Now a valid state */

TCP_MAX_STATES  /* Leave at the end! */
</code></pre>

<p>};</p>

<p>{% endcodeblock   %}</p>

<!-- more -->


<p>用<code>cat /proc/net/tcp</code>打印时，输出所有active connections，
<a href="%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D">http://search.cpan.org/~salva/Linux-Proc-Net-TCP-0.03/lib/Linux/Proc/Net/TCP.pm#The_/proc/net/tcp_documentation</a>。</p>

<p><code>st</code>这一列即代表连接状态，下面该怎么做，你懂的。</p>

<p>要想快速高效的显示连接状态信息，推荐用(ss)[http://stackoverflow.com/questions/11763376/difference-between-netstat-and-ss-in-linux]。
Have fun.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVS peristent代码分析]]></title>
    <link href="http://gekben.gitcd.com/blog/2012/07/11/study-on-lvs-kernel-code/"/>
    <updated>2012-07-11T12:24:00+08:00</updated>
    <id>http://gekben.gitcd.com/blog/2012/07/11/study-on-lvs-kernel-code</id>
    <content type="html"><![CDATA[<p>一直纠结于LVS使用persistent时，是以何为依据，决定一个新的连接请求的命运的：是被persistent管理，去到之前的real server，还是被调度算法重新调度，去到新的real server。
代码里其实写得非常清楚：</p>

<h2>Persistent in LVS(ipvs)</h2>

<ul>
<li>fwmark

<ul>
<li>&lt;IPPROTO_IP,caddr,0,fwmark,0,daddr,0> 这个六元组，最开始是写死的
ip协议，第一个0是cport，第二个0是dport，就是不在乎cport和dport，
这个daddr值得一提，经过debug发现，这个值为<code>0.0.0.fwmark</code>。</li>
</ul>
</li>
<li>Port zero service &lt;protocol,caddr,0,vaddr,0,daddr,0></li>
<li>non Port zero service

<ul>
<li>FTP &lt;caddr,0,vaddr,0,daddr,0></li>
<li>NON-FTP &lt;caddr,0,vaddr,vport,daddr,dport></li>
</ul>
</li>
</ul>


<!-- more -->


<p>  <br/>
如果是transparent mode，这种透明模式一般都是通过fwmark的方式实现，客户
端是不知道vip的存在的，比如用<code>iptables</code>设置了<code>fwmark</code>为3，则访问
http://sina.com.cn时，<code>daddr</code>就是<code>0.0.0.3</code>。</p>

<p>见代码17，21，77，80行。
{% codeblock /net/netfilter/ipvs/ip_vs_core.c lang:c %}</p>

<pre><code>/*
 * As far as we know, FTP is a very complicated network protocol, and
 * it uses control connection and data connections. For active FTP,
 * FTP server initialize data connection to the client, its source port
 * is often 20. For passive FTP, FTP server tells the clients the port
 * that it passively listens to,  and the client issues the data
 * connection. In the tunneling or direct routing mode, the load
 * balancer is on the client-to-server half of connection, the port
 * number is unknown to the load balancer. So, a conn template like
 * &lt;caddr, 0, vaddr, 0, daddr, 0&gt; is created for persistent FTP
 * service, and a template like &lt;caddr, 0, vaddr, vport, daddr, dport&gt;
 * is created for other persistent services.
 */
if (ports[1] == svc-&gt;port) {
    /* Check if a template already exists */
    if (svc-&gt;port != FTPPORT)
        ct = ip_vs_ct_in_get(svc-&gt;af, iph.protocol, &amp;snet, 0,
                     &amp;iph.daddr, ports[1]); /* &lt;caddr,0,vaddr,vport,daddr,dport&gt; */
    else
        ct = ip_vs_ct_in_get(svc-&gt;af, iph.protocol, &amp;snet, 0,
                     &amp;iph.daddr, 0);        /* &lt;caddr,0,vaddr,0,daddr,0&gt; */

    if (!ct || !ip_vs_check_template(ct)) {
        /*
         * No template found or the dest of the connection
         * template is not available.
         */
        dest = svc-&gt;scheduler-&gt;schedule(svc, skb);
        if (dest == NULL) {
            IP_VS_DBG(1, "p-schedule: no dest found.\n");
            return NULL;
        }

        /*
         * Create a template like &lt;protocol,caddr,0,
         * vaddr,vport,daddr,dport&gt; for non-ftp service,
         * and &lt;protocol,caddr,0,vaddr,0,daddr,0&gt;
         * for ftp service.
         */
        if (svc-&gt;port != FTPPORT)
            ct = ip_vs_conn_new(svc-&gt;af, iph.protocol,
                        &amp;snet, 0,
                        &amp;iph.daddr,
                        ports[1],
                        &amp;dest-&gt;addr, dest-&gt;port,
                        IP_VS_CONN_F_TEMPLATE,
                        dest);
        else
            ct = ip_vs_conn_new(svc-&gt;af, iph.protocol,
                        &amp;snet, 0,
                        &amp;iph.daddr, 0,
                        &amp;dest-&gt;addr, 0,
                        IP_VS_CONN_F_TEMPLATE,
                        dest);
        if (ct == NULL)
            return NULL;

        ct-&gt;timeout = svc-&gt;timeout;
    } else {
        /* set destination with the found template */
        dest = ct-&gt;dest;
    }
    dport = dest-&gt;port;
} else {
    /*
     * Note: persistent fwmark-based services and persistent
     * port zero service are handled here.
     * fwmark template: &lt;IPPROTO_IP,caddr,0,fwmark,0,daddr,0&gt;
     * port zero template: &lt;protocol,caddr,0,vaddr,0,daddr,0&gt;
     */
    if (svc-&gt;fwmark) {
        union nf_inet_addr fwmark = {
            .ip = htonl(svc-&gt;fwmark)
        };

        ct = ip_vs_ct_in_get(svc-&gt;af, IPPROTO_IP, &amp;snet, 0,
                     &amp;fwmark, 0); /* &lt;IPPROTO_IP,caddr,0,fwmark,0,daddr,0&gt; */
    } else
        ct = ip_vs_ct_in_get(svc-&gt;af, iph.protocol, &amp;snet, 0,
                     &amp;iph.daddr, 0); /* &lt;protocol,caddr,0,vaddr,0,daddr,0&gt; */

    if (!ct || !ip_vs_check_template(ct)) {
        /*
         * If it is not persistent port zero, return NULL,
         * otherwise create a connection template.
         */
        if (svc-&gt;port)
            return NULL;

        dest = svc-&gt;scheduler-&gt;schedule(svc, skb);
        if (dest == NULL) {
            IP_VS_DBG(1, "p-schedule: no dest found.\n");
            return NULL;
        }

        /*
         * Create a template according to the service
         */
        if (svc-&gt;fwmark) {
            union nf_inet_addr fwmark = {
                .ip = htonl(svc-&gt;fwmark)
            };

            ct = ip_vs_conn_new(svc-&gt;af, IPPROTO_IP,
                        &amp;snet, 0,
                        &amp;fwmark, 0,
                        &amp;dest-&gt;addr, 0,
                        IP_VS_CONN_F_TEMPLATE,
                        dest);
        } else
            ct = ip_vs_conn_new(svc-&gt;af, iph.protocol,
                        &amp;snet, 0,
                        &amp;iph.daddr, 0,
                        &amp;dest-&gt;addr, 0,
                        IP_VS_CONN_F_TEMPLATE,
                        dest);
        if (ct == NULL)
            return NULL;

        ct-&gt;timeout = svc-&gt;timeout;
    } else {
        /* set destination with the found template */
        dest = ct-&gt;dest;
    }
    dport = ports[1];
}
</code></pre>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学写hello world之netfilter模块]]></title>
    <link href="http://gekben.gitcd.com/blog/2012/07/07/netfilter-hello-world-module/"/>
    <updated>2012-07-07T23:16:00+08:00</updated>
    <id>http://gekben.gitcd.com/blog/2012/07/07/netfilter-hello-world-module</id>
    <content type="html"><![CDATA[<p>对于linux网络的学习，学下写netfilter module更有利于理解，下面开始实战。
{% gist 3066821 %}</p>

<!-- more -->


<p>{% gist 3066825 %}</p>

<p>然后就是
{% codeblock install the module lang:bash %}</p>

<h1>make</h1>

<h1>insmod hello.ko</h1>

<p>{% endcodeblock %}</p>

<p>我的环境(archlinux64 3.31-ck)编译加载成功，但貌似会导致kernel crash，
哈哈，后面再解决吧，have fun。</p>
]]></content>
  </entry>
  
</feed>
