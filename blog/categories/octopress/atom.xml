<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: octopress | Code Mind]]></title>
  <link href="http://gekben.gitcd.com/blog/categories/octopress/atom.xml" rel="self"/>
  <link href="http://gekben.gitcd.com/"/>
  <updated>2013-03-19T08:31:40+08:00</updated>
  <id>http://gekben.gitcd.com/</id>
  <author>
    <name><![CDATA[Kevin Zeng]]></name>
    <email><![CDATA[kevintech08@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[解决octopress的git自动deploy问题]]></title>
    <link href="http://gekben.gitcd.com/blog/2012/07/12/fix-octopress-git-issuse/"/>
    <updated>2012-07-12T07:05:00+08:00</updated>
    <id>http://gekben.gitcd.com/blog/2012/07/12/fix-octopress-git-issuse</id>
    <content type="html"><![CDATA[<p>已经习惯了在折腾中学习，把遇到的问题看成是学习的机会，有了这种心态，就
不怕麻烦了。昨天晚上为了解决octopress不能<code>rake deploy</code>的问题，搞了几个
小时，搞完了对git的分支的理解得到了提升。</p>

<p>解决完了再回头看，其实我的问题很sb，master branch本来只应该包括<em>deploy
目录里的内容，但我因为误操作把上层目录都变成了master branch，这样就会
在github上自己的blog项目内，看到很多本来不属于blog的文件。当然使用
<code>rake deploy</code>也会出现问题。之前瞎折腾了很久，浪费好多时间，结果还是读
源码解决了问题，Rakefile里<code>setup_github_page</code>和<code>push</code>任务看看，就知道
咋回事了。需要注意的是，除了</em>deploy的其它文件都在source branch里，因为
<code>setup_github_page</code>初始化时把master重命名成了source。</p>

<!-- more -->


<p>{% codeblock my solution lang:bash %}
$rm -rf <em>deploy
$mkdir </em>deploy
$cd _deploy
$git init
$echo "test" > index.html
$git branch -m master
$git commit -m "octopress init"
$git remote add origin git@github.com:username/username.github.com.git
$git push origin master
{% endcodeblock %}</p>

<p>后来又遇到<code>rake generate</code>时报<code>Psych::SyntaxError</code> parse错误，表面看是说<code>_config.yml</code>有
问题，但实际问题往往出在自己写的<code>_post</code>的markdown文件上，可以在<code>psycn.rb</code>上加调试语句来发现问题。
{% codeblock my solution lang:ruby %}
  def self.parse_stream yaml, filename = nil, &amp;block</p>

<pre><code>if block_given?
  parser = Psych::Parser.new(Handlers::DocumentStream.new(&amp;block))
  # debug begin
  if filename == nil
    p yaml,"\nDebuging"
  end
  # debug end
  parser.parse yaml, filename
else
  parser = self.parser
  parser.parse yaml, filename
  parser.handler.root
end 
</code></pre>

<p>  end
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用jekyll octopress emacs写blog]]></title>
    <link href="http://gekben.gitcd.com/blog/2012/07/05/begin-to-use-jekyll/"/>
    <updated>2012-07-05T07:59:00+08:00</updated>
    <id>http://gekben.gitcd.com/blog/2012/07/05/begin-to-use-jekyll</id>
    <content type="html"><![CDATA[<p>最近学习的动力大爆发，学了不少东西，应该记录并分享出来，把自己挂在
github上的静态页面换成了强大的jekyll+octopress，捣鼓下开始写东西了，用markdown写
blog的感觉应该很棒。</p>

<p>接下来是开发环境，没错，是按写代码的方式写blog，我用的是emacs +
mardown-mode,非常爽的组合。因为我是用archlinux，用yaourt怎么
一个方便了得。</p>

<p>{% codeblock install ibus-el lang:bash %}
$ yaourt -S ibus-el
{% endcodeblock %}</p>

<!-- more -->


<p>{% codeblock ibus-mode configuration %}
(require 'ibus)
(add-hook 'after-init-hook 'ibus-mode-on)
(global-set-key (kbd "C-\") 'ibus-toggle)
{% endcodeblock %}
备注：因为ibus-mode很恼人的context warning问题，已经抛弃它了，直接把
emacs可执行文件包装一下，放在shell里:
{% codeblock my emacs wrapper script lang:bash%}</p>

<h1>!/bin/sh</h1>

<h1>emacs-real is the real original emacs executable</h1>

<p>LC_CTYPE=zh_CN.UTF-8 /usr/bin/emacs-real
{% endcodeblock %}
就可以直接使用系统的ibus了，低碳环保还不闹心。</p>

<p>{% codeblock Enable markdown mode %}
(autoload 'markdown-mode "markdown-mode.el"
   "Major mode for editing Markdown files" t)
(setq auto-mode-alist
   (cons '("\.text"  . markdown-mode) auto-mode-alist))</p>

<p>(setq auto-mode-alist</p>

<pre><code>  (cons '("\\.md"  . markdown-mode) auto-mode-alist))
</code></pre>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
